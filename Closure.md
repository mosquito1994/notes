# 闭包

1. 概述

	一个函数内部又声明了一个函数（函数表达式/匿名函数/函数声明），这个新声明的函数内部的作用域称为闭包。
2. 特点
   - 可以访问到外部函数和全局环境中所有变量
   - 有比外部函数更长的生命周期，具体表现为能够记录对外部函数中声明的变量的最后一次引用值
3. 作用域和作用域链

   a. 作用域

   	  函数当前运行和变量生效的环境。在每次调用一个函数的时候，就会进入一个函数内的作用域，当从函数返回以后，就返回调用前的作用域。
   
   b. 作用域链

   	  当调用一个变量的时候会对改变量进行解析，将会沿着“内部函数-外部函数-...-全局环境”的作用域链找寻该变量。如果找到了符合要求的变量，立即停止查找并使用当前找到的值作为变量的值。
   
   c. 函数声明与作用域链

      函数的作用域链在其声明时就已经确定。
    	

	 * 函数声明提升

	 	 凡是以函数声明形式声明的函数均会在脚本文件加载时就被提前加载（函数表达式则没有该特点），因此我们可以在一个函数声明之前调用该函数而不会报错。
     ```javascript
	 	 test(); // 控制台显示0;
	 	 test2(); //undefined

	 	 function test() {
	 	 	 console.log('0');
	 	 }

	 	 var test2 = function() {
	 		 console.log('1');
	 	 }
     ```

	 * 作用域链与变量声明
     ```javascript
	 	 var name = 'mosquito';
	 	 function test3() {
	 		 alert(name); //undefined
	 		 var name = 'lalala';
	 	 	 alert(name); // 'lalala'
	 	 }

	 	 test3();
     ```

	 	 前面已经说过了，当解析到变量的时候会顺着作用域链寻找同名变量。这里在test3声明时，name就已经存在于test3的作用域链之中，但是在第一次alert的时候，name的值尚未声明。也就是说，第一次解析name时，确实会沿着作用域链找name，但是name在test定义的时候就已经在其作用域链中了，name在这里被找到，于是停止向全局查找name。但是不巧的是，这时候name尚未定义，它的值为undefined，于是第一次返回了undefined。同理，第二次返回了'lalala'。


4. 垃圾收集

  a. 标记清除
  
    对于每个进入环境的变量，垃圾收集器都给其加上标记，然后去除变量和被变量引用的值的标记，最后剩下的还有标记的值将会认为不能起作用而被清除。
  
  b. 引用计数
  
    某一变量被声明或赋值时，其引用数加1，引用该值的变量被赋予新的值时则引用数减1.当一个变量的引用数为0将被清除。当存在循环引用的时候，这两个循环引用的变量引用数永远不会为0，因此会造成内存泄露。最早的Netscape4.0之前和ie9之前的DOM/BOM对象都是用该种方式。
